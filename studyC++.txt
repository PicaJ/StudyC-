using namespace xxx:
	从此处开始，后续代码使用此空间命名函数
namespace xxxxx{


}
	自定义命名空间

c++创建动态数组：
	type_name * pointer = new int [num]
	delete[] pointer;
	
指针：
	wages[10]
	wages = &wages[0]
指针与数组区别：
	指针名可运算，数组名仅为常量
		pointername = pointer + 1	//alllow
		array = array + 1 	//not allow
	sizeof 可返回数组的元素总和大小，指针只能返回类型大小

数组的地址：
	short tell[10]
	tell表示第一个元素的地址，&tell表示tell数组的总地址
	short (*pas)[10] = &tell
	short *pas2 = tell
	pas + 1 表示地址移动整个tell大小
	pas2 + 1 表示地址移动2字节

指针表示与数组表示互换：
	arrayname[i] <<==>> *(arrayname + i)

内存空间：
	自动存储（局部变量；函数内定义；函数生命周期，不可规划大小）、静态存储（存在整个程序周期；函数外定义；不可规划周期及大小）、自由存储（可规划生命周期和大小）

内存泄露：
	某变量被分配自由存储空间，因作用域规则和对象生命周期而被释放，没有delete，则该内存空间仍有数据，且不可使用

数组代替品：vector、array
	
函数指针：
	double (*pf)(int)	//返回double的函数指针，调用double x = pf(5);
	double *pf(int)		//返回double类指针的函数
	
函数指针数组：
	const double * (*pa[3])(const double *,int) = {f1,f2,f3};	//pa为三个函数指针的数组，其返回值为double的地址

	'[]'运算符比'*'运算符高级
	*pa[3]		//pa为数组，指向3个指针，an array of 3 pointer
	(*pa)[3]	//pa为数组指针，指向3个元素的数组，an pointer of 3 array

	const double *((*pd)[3])(const double *,int) = &pa; 
		调用方式为：(*pd)[i](av,3)或(*(*pa)[i])(av,3)
		获取返回的值：(*(*pd)[i])(av,3)或*(*(*pd)[i])(av,3)

内联函数：
	inline int add(int a,int b);	//避免函数的压栈弹栈的开销，但会使程序体积庞大

函数/运算符重载：
	通过参数列表的内容/顺序的不同重载函数
	运算符重载：type operator+(const Box&,const Box&);	//重置c++内定的运算符


模版：
	对于给定的函数名，可以有非模版、模版、显式具体以及他们的重载函数	
	模版不能对非基本类型（结构体、类）等数据类型进行运算，显式具体化可以进行此
	
	void swap(job &,job &);	//常规函数

	template <typename T> T& swap(T &,T &);	//模版函数，只可以对基本类型int double long等进行模版操作，可放在头文件，不是函数的定义

模版具体化：
	优先级：非模版函数、显式具体化原型、显式实例化、常规模版函数

	template <> void swap<job>(job &,job &); 或template <> void swap(job &,job &);	//显式具体化（explicit specialization）必须定义,专门针对特定类型的、实现方式不同的具体化函数，可以对结构体等复杂数据类型操作

	templatet void swap<int>（int ,int）;	//实例化(explicit instantitation)只需声明，swap模版专门为int类型做出定义
	
作用域：
	静态持续变量（在整个程序周期存在）:
		外部链接性：其他文件可访问（函数外定义）
		内部链接性：仅本文件可访问（函数外定义，且static修饰）
		无链接性：仅函数块内可访问（函数内定义，且static修饰）
	类作用域：
		通过对象存储类数据，即每个对象为实例化每个类的作用域

new/delete：
	delete释放内存：
		char p[]、char *p的delete方式均为：delete[] p; 
		delete后，p仍可以访问其内存数据，但随时会被回收，所以delete后常将指针设为NULL，避免访问错乱


	new定位符：
		指定使用的内存位置
			struct chaff{ char dross[20];int slag};
			double *p = new (buffer) chaff;	
			p指针的起始地址为buffer的地址
				==》》可能出现多个动态存储变量的起始地址相同

			此时不能使用delete[] p释放内存，因buffer指向的是静态内存是程序周期存在的，若p指针不设为NULL，后续仍可以继续访问其内存数据；delete释放的是指向常规new运算符分配的堆空间

命名空间：
	.h文件存放命名空间的声明部分，.cpp存放命名空间的定义部分，两者都需namespace{}包括
	using编译和声明指令均可以多个使用，但不能using重复名称

重载运算符：
	定义：type operatorop(param){....}
		例：Box operator+(const Box& b){...}
	使用：Box obj = sid + sara ==> Box obj = sid.operator+(sara)

友元：(类作用域的非成员函数，避免了通过对象的调用)
	1.为类重载二元运算符时常用，当不通过对象调用重载运算符时，就需要非类成员重载运算符函数，但需要访问类private数据时，就需要友元函数
	2.声明：在类中按此声明，表明非成员函数，但拥有其他函数相同的访问权限
		friend type operatorop(praam1,param2)
	3.定义：type operatorop(param1,param2)
		例：A = 2.75 * B ==> A = operator*(2.75，B)
	
类和动态内存分配：
	1.指针区别与数组没有预设大小，可作为动态分配，与C的malloc动态分配内存一样，new可给指针内存
	2.类静态变量不能在声明是初始化，因为声明描述了如何分配内存，但此时不分配内存，需要在类外定义（因为声明在.h文件中，在多个文件引用时，会出现重复初始化的副本），但一个例外是const修饰的static成员变量，可在声明初始化
	3.复制构造函数：
		1.当对象按值传参时，会调用复制构造函数拷贝到形参中；当对象赋值给另一对象时，同样调用复制构造函数。若无指定复制构造函数，则调用默认复制构造函数
		2.默认复制构造函数（浅复制），拷贝是按值赋值，若遇到指针，则复制指针的地址（浅复制：复制指针地址；深复制：复制指针指向内容）
			例：obj.str = obj2.str
		3.在构造函数/构析函数有new/delete等内存分配时，应制定复制构造函数

				

类的设计：
	1.私有数据成员存储信息，公有成员函数访问数据唯一途径
	2.类声明放在.h文件，类定义放在.cpp文件
	

类中定义访问权限：默认private

内联函数：（展开函数代码，节省程序时间，但代码体积变大）
	在类中定义均为内联函数；
	类外定义，需在函数类型名前添加' inline '

构造函数：
	1.传入的参数不能和类数据名称一致
	2.使用非默认构造函数：
		显式：
			class_name object = class_name(type x, type y, ...)；
		隐式：
			class_name object(type x, type y, ...)；
		new：
			class_name *object  = new class_name(type x, type y, ...);
	3.使用默认构造函数：
		class_name object;
		class_name object();
				
	4.定义了非默认构造函数后，不能隐式定义对象
		class_name::class_name()
		{
		....
		}
析构函数：
	1.若创建的时静态存储对象，将在程序结束时执行
	2.若自动存储对象，将在程序执行完代码块时执行
	3.若是new对象，将在delete释放内存时执行
	
const成员函数：
	const class_name object = class_name(...);
	被const定义的对象后，调用对象的成员函数时不可修改该对象，因此调用该对象的成员函数需要以下修饰：
		type class_name::function() const;

this指针：
	为对象的地址，*this才是对象本身；
	常用在同时处理两个对象：
		例：
		const Stock & Stock::topval(const Stock & s) const
		{
			if(s.total_val > total_val){
				return s;
			}else{
				return *this;	//对象本身
			}
		}	

类作用域：（在类中有效）
	1.enum枚举，在类中声明常量，不被对象包含，即在创建对象前存在，类中可用
	2.static修饰变量，存放在静态变量中，不存储在对象中，与所有对象共享
	3.类外定义枚举，enum class_name name {...}，避免了类外的冲突

抽象数据类型（ADT）

继承：
	1.访问权限：派生类存储基类所有数据；可以使用基类所有方法（前提基类方法不是private，且继承权限不为private）
	2.派生类构造：
		1.派生类不可直接访问基类private数据，只可通过基类方法访问
		2.构造派生类时，先构造基类（总是），基类构造初始化基类数据，派生类初始化新增数据，可以通过隐式构造函数/成员初始化列表初始化新增的数据、基类构造函数
			B :: B(par1,par2,par3) : A(par1,par2) , new_data_in_Aclass(par3)	//B为派生类，A为基类，最后为B的新增数据；即为初始化列表
		3.释放顺序与构造顺序相反，即从派生类开始析构
	3.派生类与基类特殊关系：（兼容属性）
		1.类指针作用域限定在该类中，没有派生类的数据
		2.基类指针和引用可以不进行显式类型转换下指向派生类对象（在传参时，若声明参数为基类引用或指针，则可传入基类或派生类的指针或引用）
			B obj_B(...);
			A * obj_A = obj_B;	或   A & obj_A = &obj_B;
			/*此时基类指针/引用指向了派生类的对象，但方法只能使用基类的方法，相当于从派生类初始化了基类*/
			
			type func(A &obj_A)	 ==> 可传入A obj_A 或 B obj_B	//引用
			type func(A *obj_A)	 	==> 可传入&obj_A 或 &obj_B		//指针
		3.上述方法不可逆，即派生类指针/引用不可指向基类
		4.可用派生类对象初始化基类对象：
			因基类存在默认的复制构造函数A(const A &),而因上述的引用/指针兼容，可指向派生类对象，所有有此原型：A(const B &);
	4.派生类与基类作用域不相交，各方法前有类限定作用域（A::func() 和 B::func()），因此重名同参同返回值的方法不冲突，在调用时，添加作用域解析运算即可
	5.虚函数：（在派生类中需要重新定义的方法时常用，virtual关键字只用在声明中）
		1.在继承上下类有同名方法时，无virtual修饰的方法，根据引用类型和指针类型选择版本（与兼容性有关）
			如：
			A obj_A  , B obj_B 
			A & obj_ap1 = obj_A;	//此时选择A类的版本
			A & obj_ap2 = obj_B;	//此时选择A类的版本
		2.在继承上下类有同名方法时，有virtual修饰的方法，根据引用或指针指向的对象选择版本（此时将通过派生的《对象》调用方法）
			如：
			A obj_A  , B obj_B 
			A & obj_ap1 = obj_A;	//此时选择A类的版本
			A & obj_ap2 = obj_B;	//此时选择B类的版本，通过obj_B调用方法
		3.虚析构函数作用在，按照指向的对象调用析构函数，避免基类指针指向派生类时，不调用派生类的析构函数，而只调用基类的析构函数

静态联编与动态联编：
	1.C++中，类型转换严格要求，不同类型的转换需要显示转换
	2.在继承的指针/引用兼容性中，基类指向派生类不需显示转换，为向上强制转换；而派生类指向基类时，需要显示转换，为向下强制转换
	3.使用基类引用或指针作为参数时，传入基类指向派生类的指针或引用会按对象调用方法；而使用基类的值作为参数时，传入的基类指向派生类只会传入基类的属性，导致调用仅采用基类的方法（c++ primer plus p410）
	4.若不适用虚函数，则在编译阶段可完成函数名的联编；若使用虚函数，则需要在运行阶段确认了指向对象后，才能完成函数联编，即为动态联编
	5.静态联编比动态效率高；
	







		
				      		
		
























































